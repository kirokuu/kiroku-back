# Kiroku 프로젝트 개선사항

## 1. 코드 구조 및 일관성 개선

### 1.1 응답 처리 표준화
- **문제점**: 
  - `ResponseResult` 클래스를 상속받는 여러 응답 클래스들(`LoginResponse`, `JoinResponse`, `UserInfoResponse`)이 일관되지 않은 방식으로 구현되어 있습니다.
  - `JoinStatus`와 `LoginStatus`의 구조가 다릅니다.
  - 일부 컨트롤러 메서드는 `ResponseResult`를 반환하고, 일부는 단순 `ResponseEntity`를 반환합니다.

- **해결 방안**:
  - 모든 응답 클래스가 동일한 패턴을 따르도록 표준화합니다.
  - 모든 상태 열거형(enum)이 동일한 구조(메시지와 코드)를 가지도록 합니다.
  - 모든 컨트롤러 메서드가 일관된 응답 형식을 사용하도록 합니다.

### 1.2 패키지 구조 개선
- **문제점**: 
  - `JoinStatus`가 `user` 패키지와 `user.dto` 패키지에 중복되어 있습니다.
  - DTO 클래스들이 일관되지 않은 위치에 있습니다.

- **해결 방안**:
  - 중복된 클래스를 제거하고 일관된 패키지 구조를 유지합니다.
  - 모든 DTO 클래스를 해당 도메인의 dto 패키지에 위치시킵니다.

## 2. 보안 개선

### 2.1 민감 정보 노출 방지
- **문제점**: 
  - `UserInfoResponse`에 비밀번호가 포함되어 있습니다.
  - JWT 비밀 키가 application.yml에 하드코딩되어 있습니다.
  - 데이터베이스 접속 정보가 하드코딩되어 있습니다.

- **해결 방안**:
  - `UserInfoResponse`에서 비밀번호 필드를 제거하거나 마스킹 처리합니다.
  - 환경 변수나 외부 설정을 통해 민감 정보를 관리합니다.
  - 프로덕션 환경에서는 암호화된 방식으로 민감 정보를 저장합니다.

### 2.2 CORS 설정 일관성 확보
- **문제점**: 
  - CORS 설정이 nginx와 Spring 애플리케이션 양쪽에서 중복되어 있습니다.
  - WebConfig에서 "https://kirocu.store"가 누락되어 있습니다.

- **해결 방안**:
  - CORS 설정을 한 곳에서만 관리하거나, 양쪽이 일관되게 설정되도록 합니다.
  - WebConfig에 "https://kirocu.store"를 추가합니다.

### 2.3 보안 설정 강화
- **문제점**: 
  - SecurityConfig에서 모든 요청("/**")에 대해 permitAll()을 설정하여 보안이 약화될 수 있습니다.
  - CSRF 보호가 비활성화되어 있습니다.

- **해결 방안**:
  - 인증이 필요한 엔드포인트와 그렇지 않은 엔드포인트를 명확히 구분합니다.
  - REST API에 적합한 CSRF 보호 전략을 구현합니다.

## 3. 코드 품질 개선

### 3.1 불필요한 코드 제거
- **문제점**: 
  - 주석 처리된 코드가 여러 파일에 남아있습니다.
  - 디버깅용 System.out.println이 프로덕션 코드에 남아있습니다.
  - 테스트용 사용자 데이터를 생성하는 CommandLineRunner가 프로덕션 코드에 포함되어 있습니다.

- **해결 방안**:
  - 주석 처리된 코드를 제거하거나 필요한 경우 문서화합니다.
  - 디버깅용 코드를 로깅 프레임워크를 사용하는 방식으로 변경합니다.
  - 테스트용 코드를 테스트 환경에서만 실행되도록 분리합니다.

### 3.2 코드 중복 제거
- **문제점**: 
  - 토큰 만료 시간이 application.yml과 JwtProvider 클래스에 중복되어 있습니다.
  - 유사한 기능을 하는 메서드들이 중복되어 있습니다.

- **해결 방안**:
  - 설정 값을 한 곳에서만 관리하고 주입받아 사용합니다.
  - 중복된 메서드를 리팩토링하여 코드 재사용성을 높입니다.

### 3.3 예외 처리 개선
- **문제점**: 
  - 예외 처리가 일관되지 않습니다. 일부는 커스텀 예외로 래핑하고 일부는 로깅만 합니다.
  - 일부 메서드에서는 예외를 무시하고 null이나 빈 객체를 반환합니다.

- **해결 방안**:
  - 일관된 예외 처리 전략을 수립하고 적용합니다.
  - 글로벌 예외 핸들러를 구현하여 일관된 오류 응답을 제공합니다.

## 4. 성능 및 확장성 개선

### 4.1 데이터베이스 설정 최적화
- **문제점**: 
  - JPA 설정에서 ddl-auto가 create-drop으로 설정되어 있어 프로덕션 환경에서 문제가 될 수 있습니다.
  - 데이터베이스 연결 풀 설정이 명시되어 있지 않습니다.

- **해결 방안**:
  - 환경별(개발, 테스트, 프로덕션) 설정을 분리합니다.
  - 프로덕션 환경에서는 ddl-auto를 none 또는 validate로 설정합니다.
  - 적절한 연결 풀 설정을 추가합니다.

### 4.2 캐싱 전략 도입
- **문제점**: 
  - 자주 조회되는 데이터에 대한 캐싱 전략이 없습니다.

- **해결 방안**:
  - Spring Cache 또는 Redis를 활용한 캐싱 전략을 도입합니다.
  - 특히 사용자 정보와 같이 자주 조회되는 데이터에 대해 캐싱을 적용합니다.

## 5. 테스트 코드 개선

### 5.1 테스트 커버리지 확대
- **문제점**: 
  - 테스트 코드가 충분하지 않습니다.

- **해결 방안**:
  - 단위 테스트와 통합 테스트를 추가하여 코드 커버리지를 높입니다.
  - 특히 중요한 비즈니스 로직과 보안 관련 코드에 대한 테스트를 강화합니다.

## 6. 문서화 개선

### 6.1 API 문서화 강화
- **문제점**: 
  - Swagger 주석은 있지만, 일부 API에 대한 설명이 부족합니다.

- **해결 방안**:
  - 모든 API에 대해 상세한 설명, 요청/응답 예시, 오류 코드 등을 문서화합니다.
  - README.md 파일을 확장하여 프로젝트 설정, 실행 방법, 아키텍처 등을 상세히 설명합니다.

## 7. 배포 및 운영 개선

### 7.1 환경별 설정 분리
- **문제점**: 
  - 개발, 테스트, 프로덕션 환경에 대한 설정이 분리되어 있지 않습니다.

- **해결 방안**:
  - Spring 프로필을 활용하여 환경별 설정을 분리합니다.
  - 환경 변수를 통해 민감 정보를 주입받도록 합니다.

### 7.2 로깅 전략 개선
- **문제점**: 
  - 체계적인 로깅 전략이 없습니다.

- **해결 방안**:
  - 로깅 레벨을 환경별로 적절히 설정합니다.
  - 중요한 비즈니스 이벤트와 오류에 대한 로깅을 강화합니다.
  - 로그 집계 및 모니터링 시스템 도입을 고려합니다.